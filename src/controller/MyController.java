package controller;

import java.net.URL;
import java.sql.*;
import java.util.ResourceBundle;
import org.postgresql.ds.PGSimpleDataSource;
import javafx.beans.property.SimpleStringProperty;
import javafx.beans.value.ObservableValue;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.Initializable;
import javafx.scene.control.*;
import javafx.scene.control.TableColumn.CellDataFeatures;
import javafx.util.Callback;
import javafx.scene.control.TableColumn;
import javafx.scene.control.TableView;
import javafx.scene.input.MouseEvent;

public class MyController implements Initializable {

	@SuppressWarnings("rawtypes")
	private ObservableList<ObservableList> data;
	private PGSimpleDataSource dataSource;
	private String[] inarr;
	private Connection connection;
	private Statement statement;

	@FXML
	private Label label, insertLabel;
	@FXML
	private Button loadData, chooseButton, updateButton, disconnect, deleteButton;
	@FXML
	private ProgressIndicator progress;
	@FXML
	private Tab gamerTableTab, insertTableTab;
	@SuppressWarnings("rawtypes")
	@FXML
	private TableView gamerTableView, updateTableView;
	@FXML
	private TextField dbIP, dbName, dbUser, dbPass, inputNumber, nummerTF, bezeichnungTF, gewichtTF;
	@FXML
	private TextField nummerTFI, bezeichnungTFI, gewichtTFI;

	/**
	 * handleButtonAction
	 * Will be executed, when the "connect" button in the "connect to database" is pressed. It tries to connect to a database
	 * by using the given parameters. In case they're working, the main select statement will be executed and displayed in the
	 * TableView in the next tab. 
	 * 
	 * @param event			ActionEvent generated by the click event
	 */
	@SuppressWarnings({ "unchecked", "rawtypes" })
	public void handleButtonAction(ActionEvent event) {
		
		System.out.println("Connecting to database...");

		data = FXCollections.observableArrayList();

		// data source configuration
		dataSource = new PGSimpleDataSource();
		dataSource.setServerName(dbIP.getText());
		dataSource.setDatabaseName(dbName.getText());
		dataSource.setUser(dbUser.getText());
		dataSource.setPassword(dbPass.getText());
		
		// building up the connection to the database
		try {
			connection = dataSource.getConnection();
			// prepare statement and execute it
			statement = connection.createStatement();
			ResultSet rs = statement.executeQuery("select * from produkt");

			label.setText("connected!");
			System.out.println("successfully connected!");
<<<<<<< HEAD

			// method to insert data into the tableView is called
			getTable();

			// error handling with error messages
		} catch (org.postgresql.util.PSQLException e) {
			System.err.println("Error");
			label.setText("Error");
			e.printStackTrace(System.err);
		} catch (SQLException se) {
			System.err.println("Error");
			label.setText("Error");
			se.printStackTrace(System.err);
		}
	}

	/**
	 * updateClicked 
	 * will be executed, if the "update" button for the row update
	 * is pressed. It takes the given parameters and puts them into a SQL
	 * statement, which is protected by a transaction.
	 * 
	 * @param event
	 *            ActionEvent generated by the click event
	 * @throws SQLException
	 *             could throw a SQLException, caused by the rollback() method
	 */
	@FXML
	public void updateClicked(ActionEvent event) throws SQLException {

		try {
			/*String sql = "UPDATE produkt SET bezeichnung=\'" + bezeichnungTF.getText() + "\', gewicht=\'"
					+ gewichtTF.getText() + "\' WHERE nummer=\'" + inarr[0] + "\'";
			
			PreparedStatement statement = connection.prepareStatement(sql);
			statement.executeUpdate();*/
			
			Statement statement = connection.createStatement();

			// transaction opened
			connection.setAutoCommit(false);
			statement.executeUpdate("UPDATE produkt SET bezeichnung=\'" + bezeichnungTF.getText() + "\', gewicht=\'"
					+ gewichtTF.getText() + "\' WHERE nummer=\'" + inarr[0] + "\'");
			// transaction committed
			connection.commit();

			System.out.println("Update successful");

			updateTableClicked(null);

		} catch (SQLException se) {
			// transaction rollback in case of an error with the SQL statement
			connection.rollback();
			System.err.println("Update Error");
			se.printStackTrace(System.err);
  		 } finally {
			if (statement != null) {
				// transaction closed
				statement.close();
			}
		}
	}

	/**
	 * getTable
	 * detects, how many columns in the tableView will be needed and inserts the data into it.
	 */
	@SuppressWarnings({ "unchecked", "rawtypes" })
	public void getTable() {

		try {

=======
			
>>>>>>> parent of 4f74308... updated JavaDoc & small restructuring
			// the tabs are accessible, in case of a successful connection
			// and the progress indicator will be set to "finished"
			gamerTableTab.setDisable(false);
			insertTableTab.setDisable(false);
			progress.setProgress(100);
<<<<<<< HEAD
=======
			
			// clear all columns in the tableView
			gamerTableView.getColumns().clear();

			data.clear();
			data = FXCollections.observableArrayList();
>>>>>>> parent of 4f74308... updated JavaDoc & small restructuring

			// this algorithm detects the number of columns
			for (int i = 0; i < rs.getMetaData().getColumnCount(); i++) {
				// We are using non property style for making dynamic table
				final int j = i;
				TableColumn col = new TableColumn(rs.getMetaData().getColumnName(i + 1));
				col.setCellValueFactory(
						new Callback<CellDataFeatures<ObservableList, String>, ObservableValue<String>>() {
							public ObservableValue<String> call(CellDataFeatures<ObservableList, String> param) {
								return new SimpleStringProperty(param.getValue().get(j).toString());
							}
						});

				gamerTableView.getColumns().addAll(col);
			}

			// save results in ObservableList data which will be added to the tableView
			while (rs.next()) { // move cursor
				ObservableList<String> row = FXCollections.observableArrayList();
				for (int i = 1; i <= rs.getMetaData().getColumnCount(); i++) {
					// Iterate Column
					row.add(rs.getString(i));

				}
				data.add(row);
			}

			// adding the data to the tableView
			gamerTableView.setItems(data);

			// after the successful connection construction, the connect button will (logically) disabled
			// and the disconnect button enabled
			loadData.setDisable(true);
			disconnect.setDisable(false);

			// error handling with error messages
		} catch (org.postgresql.util.PSQLException e) {
			System.err.println("Error");
			label.setText("Error");
			e.printStackTrace(System.err);
		} catch (SQLException se) {
			System.err.println("Error");
			label.setText("Error");
			se.printStackTrace(System.err);
		}
	}

	/**
	 * updateClicked
	 * will be executed, if the "update" button for the row update is pressed. It takes the given parameters and puts
	 * them into a SQL statement, which is protected by a transaction.
	 * 
	 * @param event				ActionEvent generated by the click event
	 * @throws SQLException		could throw a SQLException, caused by the rollback() method
	 */
	@FXML
	public void updateClicked(ActionEvent event) throws SQLException {

		try {
			Statement statement = connection.createStatement();

			// transaction opened
			connection.setAutoCommit(false);
			statement.executeUpdate("UPDATE produkt SET bezeichnung=\'" + bezeichnungTF.getText() + "\', gewicht=\'"
					+ gewichtTF.getText() + "\' WHERE nummer=\'" + inarr[0] + "\'");
			// transaction committed
			connection.commit();

			System.out.println("Update successful");

			updateTableClicked(null);

		} catch (SQLException se) {
			// transaction rollback in case of an error with the SQL statement
			connection.rollback();
			System.err.println("Update Error");
			se.printStackTrace(System.err);
		} finally {
			if (statement != null) {
				// transaction closed
				statement.close();
			}
		}
	}

	/**
	 * updateTableClicked
	 * will be executed, when the upper "update" button for the tableView is pressed. Clears the whole tableView
	 * to add the latest data.
	 * 
	 * @param event			ActionEvent generated by the click event
	 */
	@FXML
	public void updateTableClicked(ActionEvent event) {

		// clear all columns in the tableView
		gamerTableView.getColumns().clear();

		data.clear();
		data = FXCollections.observableArrayList();

<<<<<<< HEAD
		// new data is inserted
//		handleButtonAction(null);
		getTable();
=======
		// new data is inserted 
		handleButtonAction(null);
>>>>>>> parent of 4f74308... updated JavaDoc & small restructuring

	}

	/**
	 * disconnectPressed
	 * disconnect button pressed; tabs will be deactivated and the textfields reset for clean reuse. 
	 * simple explained: the program will be "reseted"
	 * 
	 * @param event		ActionEvent generated by the click event
	 */
	@FXML
	public void disconnectPressed(ActionEvent event) {

		try {
			connection.close();

			label.setText("not connected");
			gamerTableTab.setDisable(true);
			insertTableTab.setDisable(true);
			progress.setProgress(0);
			loadData.setDisable(false);
			disconnect.setDisable(true);
			
			nummerTF.setText("");
			bezeichnungTF.setText("");
			gewichtTF.setText("");
			
			nummerTFI.setText("");
			bezeichnungTFI.setText("");
			gewichtTFI.setText("");
			
			updateButton.setDisable(true);
			deleteButton.setDisable(true);
			
			System.out.println("Disconnected");

		} catch (SQLException e) {
			System.err.println("Connection could not be closed!");
			label.setText("Error");
			e.printStackTrace();
		}

	}

	/**
	 * insertClicked
	 * checks if the given input for the insert is valid. In this case, it will be inserted into
	 * the database. 
	 * 
	 * @param event				ActionEvent generated by the click event
	 * @throws SQLException		could throw a SQLException, caused by the rollback() method
	 */
	@FXML
	public void insertClicked(ActionEvent event) throws SQLException {

		// checks, if the necessary values are numeral (nummer, gewicht)
		if (nummerTFI.getText().matches("^-?\\d+$") && gewichtTFI.getText().matches("^-?\\d+$")) {

			int num = Integer.parseInt(nummerTFI.getText());
			int gew = Integer.parseInt(gewichtTFI.getText());
			String bez = bezeichnungTFI.getText();

			try {

				// transaction started
				connection.setAutoCommit(false);
				statement.executeUpdate("INSERT INTO produkt VALUES (" + num + ", '" + bez + "', '" + gew + "')");
				// transaction committed
				connection.commit();

				System.out.println("Insert successful!");
				insertLabel.setText("Insert successful");

			} catch (SQLException e) {
				// transaction rollback in case of an SQL error
				connection.rollback();
				insertLabel.setText("Insert error!");
				System.err.println("Insert error!");
				e.printStackTrace();

			} finally {
				if (statement != null) {
					// transaction closed
					statement.close();
				}
			}

		} else {
			insertLabel.setText("ERROR: check your input! nummer and gewicht have to be integer!");
		}
	}

	/**
	 * onMouseClicked
	 * will be executed, if the user clicks inside the tableView on a cell. This method reads the 
	 * data, which is inside the clicked row.
	 * 
	 * @param event		MouseEvent generated by the mouse event
	 */
	@FXML
	public void onMouseClicked(MouseEvent event) {

		// get the clicked row 
		@SuppressWarnings("rawtypes")
		TablePosition focusedCell = gamerTableView.getFocusModel().getFocusedCell();
		int row = focusedCell.getRow();

		// get the data of this row
		String input = data.get(row) + "";

		// the [] of the string are removed
		input = input.substring(1, input.length() - 1);

		// split the string up at ", "
		inarr = input.split(", ");

		// enable the update button, to enable the user to click it, as now the cell is chosen
		updateButton.setDisable(false);
		deleteButton.setDisable(false);

		// the content of the chosen row is inserted into the textfields
		nummerTF.setText(inarr[0]);
		bezeichnungTF.setText(inarr[1]);
		gewichtTF.setText(inarr[2]);

		bezeichnungTF.setDisable(false);
		gewichtTF.setDisable(false);

	}
	
	/**
	 * deleteClicked
	 * this method will be executed, when the delete button is pressed in the output tab. It will execute a delete SQL statment
	 * which deletes the selected row.
	 * 
	 * @param event				MouseEvent generated by the mouse event
	 * @throws SQLException		could throw a SQLException, caused by the rollback() method
	 */
	@FXML
	public void deleteClicked(ActionEvent event) throws SQLException{
		
		try {
			Statement statement = connection.createStatement();

			// transaction opened
			connection.setAutoCommit(false);
			statement.executeUpdate("DELETE FROM produkt WHERE nummer=\'" + inarr[0] + "\'");
			// transaction committed
			connection.commit();

			System.out.println("Update successful");

			updateTableClicked(null);

		} catch (SQLException se) {
			// transaction rollback in case of an error with the SQL statement
			connection.rollback();
			System.err.println("Update Error");
			se.printStackTrace(System.err);
		} finally {
			if (statement != null) {
				// transaction closed
				statement.close();
			}
		}
		
	}
	
	/**
	 * initialize 
	 * necessary method of Initializable
	 */
	@Override
	public void initialize(URL location, ResourceBundle resources) {
		// not much to do here...
	}
}
